Thanks for the clarification — I now have everything I need.

I'll look into whether Common Ground (as of the current version of `cg-plugin-lib` and `cg-plugin-lib-host`) offers any way for custom plugin backend routes to verify that a request:
- Came from the authenticated iframe context inside CG;
- Was initiated by a specific authenticated user with certain roles;
- Is cryptographically verifiable (e.g., via signed tokens or request verification).

I’ll also check whether CG recommends the current trust-based model for securing plugin-specific backend routes or whether a stronger pattern is supported but undocumented.

I’ll report back shortly with implementation recommendations and security guidance.

# Authenticating Custom Plugin Backend Requests in Common Ground

## Common Ground Plugin Authentication Basics  
Common Ground’s plugin system uses a **public/private key pair** to secure communication between the plugin iframe and the Common Ground host platform. When you create a plugin, you receive a unique key pair (public and private key) for that plugin ([GitHub - Common-Ground-DAO/CGPluginLib](https://github.com/Common-Ground-DAO/CGPluginLib#:~:text=How%20do%20I%20create%20my,plugin)). The Common Ground Plugin Library (`@common-ground-dao/cg-plugin-lib`) leverages these keys to **cryptographically sign every request** from the plugin iframe to the Common Ground backend ([GitHub - Common-Ground-DAO/CGPluginLib](https://github.com/Common-Ground-DAO/CGPluginLib#:~:text=%2A%20Secure%20Communication%3A%20All%20plugin,if%20plugin%20has%20permission)) ([GitHub - Common-Ground-DAO/CGPluginLib](https://github.com/Common-Ground-DAO/CGPluginLib#:~:text=Due%20to%20the%20sandboxed%20environment%2C,care%20of%20the%20security%20details)). This ensures the Common Ground platform can verify that incoming plugin requests are authentic and haven’t been tampered with. In practice, the plugin’s frontend does not hold the private key directly; instead, the plugin’s backend provides a signing service. The plugin iframe is initialized with an `iframeUid` (passed as a URL parameter) and uses a signing endpoint on the plugin’s own server to get its requests signed with the plugin’s private key ([CGPluginLib/README.md at main · Common-Ground-DAO/CGPluginLib · GitHub](https://github.com/Common-Ground-DAO/CGPluginLib/blob/main/README.md#:~:text=3,application%2C%20typically%20something%20like%20%27%2Fsign)) ([CGPluginLib/README.md at main · Common-Ground-DAO/CGPluginLib · GitHub](https://github.com/Common-Ground-DAO/CGPluginLib/blob/main/README.md#:~:text=npm%20install%20%40common)). An example from the documentation illustrates a `/sign` route where the server (using `@common-ground-dao/cg-plugin-lib-host`) signs a request payload with the plugin’s private key and returns the signature ([CGPluginLib/README.md at main · Common-Ground-DAO/CGPluginLib · GitHub](https://github.com/Common-Ground-DAO/CGPluginLib/blob/main/README.md#:~:text=const%20cgPluginLibHost%20%3D%20await%20CgPluginLibHost,signRequest%28body)). This mechanism confirms to Common Ground that a request truly originated from your approved plugin code. 

However, it’s important to note what this signing covers (and what it doesn’t). **This built-in signature system verifies the plugin’s identity to Common Ground** – i.e. that “Plugin X” is making a request – **but it does not inherently convey which user is making the request or add any user-specific token**. The signing mechanism guards against a malicious third-party impersonating your plugin **to the Common Ground platform**, ensuring “no one can tamper with your frontend and impersonate you” ([CGPluginLib/README.md at main · Common-Ground-DAO/CGPluginLib · GitHub](https://github.com/Common-Ground-DAO/CGPluginLib/blob/main/README.md#:~:text=3,application%2C%20typically%20something%20like%20%27%2Fsign)). But when it comes to your plugin’s **own backend API** (custom routes you host, such as your `/api/wizards` example), the plugin library does **not automatically include a user/session token** or signature for those calls. In other words, Common Ground’s provided libraries secure the **plugin-to-CommonGround channel**, but they do **not** natively secure the **plugin-frontend to plugin-backend channel** beyond any identifiers you manually pass.

## Lack of Built-In User/Session Tokens for Plugin Backends  
Neither `cg-plugin-lib` (frontend) nor `cg-plugin-lib-host` (backend) issues a user-specific session token that your custom backend can validate out-of-the-box. There is no JWT or signed user identity token provided by Common Ground for plugin use, according to the current documentation. The focus of the official library is on signing requests **to Common Ground’s API**, not on signing or authenticating requests headed to your own server. For example, the server library’s primary functionality is to sign requests from the frontend with the plugin’s private key ([CGPluginLib/README.md at main · Common-Ground-DAO/CGPluginLib · GitHub](https://github.com/Common-Ground-DAO/CGPluginLib/blob/main/README.md#:~:text=npm%20install%20%40common)) ([CGPluginLib/README.md at main · Common-Ground-DAO/CGPluginLib · GitHub](https://github.com/Common-Ground-DAO/CGPluginLib/blob/main/README.md#:~:text=const%20cgPluginLibHost%20%3D%20await%20CgPluginLibHost,signRequest%28body)) – it doesn’t produce any token asserting “User A in Community B initiated this.” As a result, when your plugin’s frontend calls your backend (for instance, a POST to `/api/wizards`), the request typically includes some context like `iframeUid` and `community_id` (perhaps along with a user identifier if your code adds it), but **these are just plain parameters**. By default there is **no cryptographic signature or Common Ground-issued token** attached to those parameters that the backend could verify. 

In practice, this means your plugin backend currently has no inherent way to know for certain that `iframeUid=XYZ` and `community_id=123` in a request were genuinely set by your iframe running inside Common Ground, or that they correspond to the authenticated user you think they do. The Common Ground libraries do not sign these fields, nor do they provide a header like an HMAC or JWT that ties the request to a user session. We also have no indication in Common Ground’s public resources that there’s any hidden API for validating a user’s session on the plugin side. For example, there’s no documented method such as “verifyToken(token)” in `cg-plugin-lib-host` – its concern is signing plugin requests to the **Common Ground** backend, not verifying requests coming **into** your plugin’s backend.

## Verifying Plugin Iframe Requests – Challenges and Options  
Because of the above, **there is currently no foolproof, built-in way to cryptographically verify on your server that an incoming request truly came from the plugin’s iframe and an authenticated user**. The `iframeUid` itself is not a secret; it’s provided as a URL param to the plugin app ([CGPluginLib/README.md at main · Common-Ground-DAO/CGPluginLib · GitHub](https://github.com/Common-Ground-DAO/CGPluginLib/blob/main/README.md#:~:text=The%20iframe%20ID%20is%20always,refer%20to%20the%20section%20below)). An attacker could potentially discover or guess valid `community_id` and `iframeUid` values and attempt to call your plugin’s APIs (for instance by curling your endpoints). Without additional measures, your backend wouldn’t know the difference between a request from your actual plugin iframe versus a forged request that simply passes the right identifiers. This is a fundamental limitation of a pure trust-based approach: **the backend is trusting the frontend to have enforced all authz checks**, but the backend isn’t verifying them on its own. 

So what can a plugin developer do? In the current system, **most plugins must rely on the trust model** – i.e. assume that if the frontend logic only calls certain routes after confirming the user’s roles via `getUserInfo()`, then those requests are legitimate. Common Ground implicitly recommends this model by providing the role info to the plugin and expecting the plugin to gate its UI/actions accordingly. For now, if you need stronger guarantees, you would have to implement them yourself on top of what Common Ground provides. Some possible strategies include: 

- **Server-Side Role Verification:** On receiving a request, your backend could call Common Ground’s public API (if one exists for retrieving user info or roles for a given community) using the plugin’s credentials to double-check the user’s privileges. For example, if a request claims to be from user X in community Y, your server (which does hold the plugin’s private key) could query Common Ground for user X’s roles in Y before processing an admin-only action. This at least ensures the user **is** an admin of that community, not an arbitrary outsider. However, note that this still doesn’t prove the caller **is** user X – it only verifies user X *should* have access. A determined attacker could spoof an admin’s user ID; this check wouldn’t catch that impersonation. It’s a partial measure, not a complete authentication. 

- **Ephemeral Session Tokens (Custom):** You could establish a session handshake between your plugin frontend and backend. For instance, when the plugin loads in the iframe, have it immediately make a request to your backend to register its session. Your backend could generate a random session token (or set a secure cookie) tied to that specific `iframeUid` or user. Subsequent calls would need to include this token. This approach mimics a typical web app login session. It doesn’t cryptographically tie to Common Ground’s auth, but it raises the bar by requiring knowledge of an unpredictable token. An attacker who just knows an `iframeUid` wouldn’t have the session token. The downside is that it’s still ultimately “trust by obscurity” – a user with access to the iframe (even a non-admin user) could retrieve their token and potentially reuse it or share it. It also doesn’t stop a malicious user who *does* have legitimate access from abusing your API (e.g., a non-admin user might still attempt an admin API call if the backend isn’t double-checking roles). 

- **User-Specific Crypto (Advanced Custom):** In a web3 context, if users authenticate to Common Ground via wallets or identity keys, you could leverage that. For critical actions, your plugin could ask the user to sign a message with their wallet and send that signature to your backend. Your backend would then verify the signature against the user’s public address (which you got via `getUserInfo()`). This would **cryptographically confirm the user’s identity** for that request. While this is strong security, it’s cumbersome – prompting wallet signatures frequently is poor UX, and it’s not natively integrated with the Common Ground plugin API. It’s an extreme option if you absolutely require high-security authentication for a plugin action (and users are willing to tolerate the extra steps).

In summary, without built-in session tokens, any solution will be custom. **Currently, the easiest and intended path is to trust the front-end**: use `CgPluginLib.getUserInfo()` to check the user and roles client-side, show or enable the appropriate actions in the UI, and assume calls hitting your backend were made by a user who passed those checks. If your plugin’s functionality isn’t high-stakes (e.g., not moving funds or performing irreversible actions), this model may be acceptable in the interim. Nevertheless, you should be aware of the risk: a determined actor could bypass your UI and call your endpoints directly. If you have endpoints that should be restricted (like an admin-only mutation), consider adding at least a server-side role verification or a simple shared secret to mitigate trivial spoofing.

## Common Ground’s Recommended Model (Trust-Based) vs. Possible Future Improvements  
As of now (early 2025), **Common Ground has not announced any stronger authentication mechanism for plugin backends beyond the trust-and-verify approach described**. All official emphasis is on securing the plugin <-> CommonGround communication channel, not the plugin’s internal API calls. There is no mention of JWTs, HMAC signatures, or OAuth-like handshakes for plugin servers in the documentation or community discussions. In fact, the Common Ground plugin introduction materials highlight that plugins run in a sandboxed iframe and can request user/community info through the secure library, but they do not describe any token passing to the plugin’s own server ([ RnDAO Newsletter 2025/14](https://www.rndao.io/blog/post/rndao-newsletter-2025-14#:~:text=Common%20Ground%20Communities%20are%20now,to%20analyze%20activity%20in%20community)). This suggests that **the current best practice (by necessity) is to rely on the front-end’s authentication and the inherent isolation of the iframe context**. Essentially, the platform is trusting that if an iframe is running your plugin (which was installed by a community admin) and if your plugin checks the user’s role before calling the backend, then the requests can be treated as legitimate. 

From a security architecture standpoint, this is a **known limitation** and one that could be improved in the future. It’s possible that Common Ground may introduce a more robust plugin authentication in later updates (for example, a way for the Common Ground host to pass a signed token to the plugin on load, which the plugin could forward to its backend for verification). In their roadmap updates, the team has mentioned work on “Agents” and “Tokens” in the context of the platform, though those seem to refer to on-chain tokens and AI assistants, not authentication tokens for plugins. As of the current release, **there is no indication of an existing hidden feature** that plugin developers can use for stronger request verification – if it’s not in the documentation, it likely doesn’t exist yet for third-party use.

Therefore, with **high confidence** we can conclude: **the trust-based model is the de facto approach for now**. Plugin developers **cannot reliably verify, in a cryptographic sense, that a request to their custom backend was initiated by a specific authenticated Common Ground user** – at least not using any built-in tool from Common Ground. The libraries `cg-plugin-lib` and `cg-plugin-lib-host` do not provide a user-auth token that your backend can check, nor a guarantee that `iframeUid/community_id` aren’t spoofed. If you need to secure your backend, you must implement additional checks or protocol on your side (as discussed above). Otherwise, you are essentially trusting that the plugin iframe’s context and Common Ground’s own authentication (plus your frontend logic) are sufficient to ensure only valid requests occur. 

## Conclusion  
In summary, **Common Ground’s plugin framework currently lacks a robust, end-to-end solution for authenticating requests to your plugin’s custom backend routes**. The provided libraries ensure that your plugin’s interactions with the Common Ground platform are secure and authenticated ([GitHub - Common-Ground-DAO/CGPluginLib](https://github.com/Common-Ground-DAO/CGPluginLib#:~:text=Due%20to%20the%20sandboxed%20environment%2C,care%20of%20the%20security%20details)), but when your plugin itself acts as a server, you do not get a turnkey method to verify the origin of incoming calls. There are no built-in signed user session tokens or headers to grab onto, and no recommended mechanism from Common Ground beyond trusting your iframe and role-checks. Practically speaking, this means **the “trust-based” model is the status quo**: your backend trusts that the frontend running within Common Ground is making legitimate requests on behalf of the user it claims. 

If this trust model is too weak for your use case, you’ll need to layer your own solution on top of it (for example, a custom signing or challenge-response system between your frontend and backend). Until Common Ground expands its plugin API to support stronger backend authentication, plugin developers must strike a balance between complexity and security on their own. **Double-check important actions** (using Common Ground’s API to confirm roles, etc.), **limit exposure of sensitive endpoints**, and be transparent with your community about any security considerations. At the moment, there is no magical configuration or hidden token in `cg-plugin-lib` that you’re missing – **what’s documented is what exists**, and that points to the current best practice being a trusted communication model supplemented by any safeguards you choose to implement.  ([GitHub - Common-Ground-DAO/CGPluginLib](https://github.com/Common-Ground-DAO/CGPluginLib#:~:text=%2A%20Secure%20Communication%3A%20All%20plugin,if%20plugin%20has%20permission)) ([CGPluginLib/README.md at main · Common-Ground-DAO/CGPluginLib · GitHub](https://github.com/Common-Ground-DAO/CGPluginLib/blob/main/README.md#:~:text=3,application%2C%20typically%20something%20like%20%27%2Fsign))

### Sources

- Common Ground Plugin Library – *README (GitHub)* ([GitHub - Common-Ground-DAO/CGPluginLib](https://github.com/Common-Ground-DAO/CGPluginLib#:~:text=%2A%20Secure%20Communication%3A%20All%20plugin,if%20plugin%20has%20permission)) ([GitHub - Common-Ground-DAO/CGPluginLib](https://github.com/Common-Ground-DAO/CGPluginLib#:~:text=Due%20to%20the%20sandboxed%20environment%2C,care%20of%20the%20security%20details)) ([GitHub - Common-Ground-DAO/CGPluginLib](https://github.com/Common-Ground-DAO/CGPluginLib#:~:text=How%20do%20I%20create%20my,plugin))  
- Common Ground Plugin Library – *Server Signing Example* ([CGPluginLib/README.md at main · Common-Ground-DAO/CGPluginLib · GitHub](https://github.com/Common-Ground-DAO/CGPluginLib/blob/main/README.md#:~:text=npm%20install%20%40common)) ([CGPluginLib/README.md at main · Common-Ground-DAO/CGPluginLib · GitHub](https://github.com/Common-Ground-DAO/CGPluginLib/blob/main/README.md#:~:text=const%20cgPluginLibHost%20%3D%20await%20CgPluginLibHost,signRequest%28body))  
- RnDAO Newsletter – *Common Ground Plugins Intro* ([ RnDAO Newsletter 2025/14](https://www.rndao.io/blog/post/rndao-newsletter-2025-14#:~:text=Common%20Ground%20Communities%20are%20now,to%20analyze%20activity%20in%20community))