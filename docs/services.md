Great, I’ll prepare a detailed technical document for your cursor agent that explains how to integrate various third-party services (guild.xyz, Discord, Telegram, ENS, EFP, docs.passport.xyz) into your onboarding wizard plugin for Common Ground.

The document will cover:
1. Required SDKs, APIs, libraries, and authentication flows needed for each integration.
2. What configuration steps the community admin must complete to enable each service.
3. What the user flow looks like during onboarding (e.g., how a user connects their Discord and proves server membership).

I’ll also make recommendations on general libraries or patterns to support flexible integration of many services in the future. I’ll let you know as soon as it’s ready.

# Common Ground Onboarding Wizard – Third‑Party Integration Guide

## Introduction

The Common Ground (CG) onboarding wizard plugin is a Next.js application that guides new community members through a series of identity and account verification steps. This plugin is **modular and configurable**, allowing a community admin to define a custom onboarding flow composed of third-party authentication or verification steps. Each step, when completed successfully, can automatically assign a corresponding role in the Common Ground platform to the user. This document provides a technical deep-dive into integrating the following third-party services as optional steps in the onboarding flow:

- **Guild.xyz** – a Web3 membership management protocol for gating access based on on-chain/off-chain criteria.
- **Discord** – the popular chat platform, used here to verify server membership or roles via OAuth2 and/or bot API.
- **Telegram** – messaging platform, used to verify membership in a Telegram group via its login widget and Bot API.
- **ENS (Ethereum Name Service)** – decentralized naming system for Ethereum; used to verify a user’s ENS domain ownership or profile.
- **EFP (Ethereum Follow Protocol)** – an on-chain social graph protocol for Ethereum accounts ([Integrations | EFP](https://efp.app/integrations#:~:text=Ethereum%20Follow%20Protocol%20,and%20Sign%20in%20with%20Ethereum)), used to verify on-chain “follows” (e.g. ensuring a user follows a specific Ethereum address).
- **Gitcoin Passport** – an identity trust score system (Passport by Gitcoin) that aggregates verifications (stamps) to prove the user’s humanity or trustworthiness.

For each service, we outline the technical requirements for integration, the setup or configuration needed by a community admin to enable it, and the user’s experience during that step of the onboarding. The aim is to help a full-stack developer implement a **scalable, plugin-based auth integration system** that can accommodate these services in a configurable way.

## Architectural Considerations for a Modular Integration

Building a modular onboarding plugin that supports many authentication/verification providers requires careful architectural planning. Here are general patterns and libraries to consider:

- **Use Standard Auth Libraries:** Leverage frameworks like **NextAuth.js** (for Next.js) or **Passport.js** to handle OAuth2 flows. NextAuth has built-in providers (e.g. Discord) and allows custom OAuth or credential providers which can simplify integration and session management. Passport.js offers strategies for many services (e.g. `passport-discord` for Discord OAuth), which can be integrated in a Next.js API route if NextAuth is not used.
- **Wallet Connection and Web3:** Many services (Guild, ENS, EFP, Passport) rely on Ethereum wallet authentication. Use libraries like **ethers.js** for blockchain interactions and **web3modal/wagmi/RainbowKit** for a user-friendly wallet connect flow. These enable **WalletConnect** support and multi-wallet integration, ensuring users can connect their MetaMask or other wallets easily. Implement **Sign-In with Ethereum (SIWE)** if you need to establish a session tied to the wallet address (this can provide an extra security layer by verifying the user’s signature).
- **Modular Design Pattern:** Abstract each integration into a module with a common interface. For example, define a base interface for “Onboarding Step” with methods such as `initiateAuth()` (to start OAuth or prompt wallet connection), `callbackHandler()` (to handle OAuth callbacks or transaction confirmations), and `verifyCondition()` (to perform the verification check, e.g. query an API or blockchain). Each service module (DiscordModule, GuildModule, etc.) can implement these. This allows the admin to **enable/disable steps via config** without code changes.
- **Configuration Management:** Store configuration for each service (API keys, IDs, tokens, etc.) securely. Sensitive credentials (API keys, Discord bot tokens) should be kept in environment variables or a secure vault, not exposed to the client. The admin UI can allow input of these values (like Discord Server ID, Telegram group, etc.) which are then saved to your database or config files. At runtime, the plugin can load the config for the current community’s onboarding flow.
- **Role Mapping:** Define how external verifications map to Common Ground roles. For example, a config might specify that “Discord verification” yields the “Member” role in CG, while “Gitcoin Passport score > 20” yields a “Verified Human” role. This mapping can be part of the config JSON or schema. The plugin should use CG’s API or SDK to assign roles to the user profile once a step is completed.
- **Asynchronous Checks & Callbacks:** OAuth-based steps (Discord, Telegram) will involve redirect callbacks. Implement Next.js API routes (or NextAuth callbacks) to handle these and then forward the result to the front-end (e.g., using a JWT or session cookie to tie the OAuth result to the user’s session). For blockchain verifications (ENS, EFP, Passport), you may perform checks client-side (via web3 or fetch) or server-side. Server-side checks (via an API route) can keep API keys secret and avoid exposing them on the client.
- **User Experience Flow:** Orchestrate the steps in a single-page wizard interface. After each step, give immediate feedback (success/failure) and only allow progression if the check passes. Provide clear instructions if a step fails (e.g., "Please join the Discord server and try again"). The steps should be independent where possible, but you can optimize (for example, if Guild and Passport both need a wallet connection, the user shouldn’t have to reconnect twice). Share state (like the connected wallet address or Discord OAuth token) between steps when relevant.
- **Libraries and Tools Summary:**  
  - *NextAuth.js* – Handles sessions and OAuth for Discord (and could be adapted for Telegram via a custom provider).  
  - *Passport.js* – Alternative to NextAuth for fine-grained control over auth flows (e.g., `passport-discord`).  
  - *ethers.js* – Ethereum library to interact with ENS and EFP contracts, and to verify signatures for Guild (EIP-712 signing).  
  - *wagmi + RainbowKit or web3modal* – To manage Ethereum wallet connections across Guild, ENS, EFP, Passport steps.  
  - *@guildxyz/sdk* – Official Guild SDK for TypeScript to interact with Guild API easily ([@guildxyz/sdk - npm](https://www.npmjs.com/package/@guildxyz/sdk#:~:text=The%20Guild%20SDK%20library%20is,any%20application%20with%20this%20SDK)).  
  - *Telegram Login Widget* – Official Telegram JavaScript for user auth, and Telegram Bot API for membership checks.  
  - *Gitcoin Passport API* – HTTP endpoints (with API key) to retrieve Passport scores.  

Below is an overview of each service’s integration method and required admin configuration:

| **Service**        | **User Auth Method**           | **Integration Mechanism**                       | **Admin Configuration**                   |
|--------------------|-------------------------------|------------------------------------------------|-------------------------------------------|
| **Guild.xyz**      | Ethereum wallet (signature)   | Guild API via official SDK (no API key needed) ([Guild SDK | Guild Knowledge Base](https://help.guild.xyz/en/articles/6947626-guild-sdk#:~:text=Guild%20SDK%20are%20open%20for,Why%20build%20with%20us)) for membership checks and joining. | Guild ID (identifier of the community’s guild); optional specific Guild Role ID if targeting a particular role. |
| **Discord**        | OAuth2 (Discord login)        | Discord OAuth2 to get user identity & guilds; Discord Bot API for guild membership/roles (requires bot in server) ([Discord Roles - Accessing - Auth0 Community](https://community.auth0.com/t/discord-roles-accessing/53219#:~:text=Discord%2C%20I%20was%20aiming%20to,attach%20it%20to%20the%20profile)). | Discord Application Client ID & Secret (if using OAuth); Discord Server ID; (Optional) Discord Role ID to check; (Optional) Bot Token if checking roles or membership via bot. |
| **Telegram**       | Telegram Login Widget         | Telegram JS widget for user auth; Telegram Bot API (`getChatMember`) to verify group membership ([How can I check whether a user is a member of a Telegram group?](https://stackoverflow.com/questions/49545889/how-can-i-check-whether-a-user-is-a-member-of-a-telegram-group#:~:text=How%20can%20I%20check%20whether,status%20for%20member%2C%20left%2C%20etc)). | Telegram Bot Token; Telegram Group Chat ID (or @username) for the community group; Bot must be added to the group (with access to member list). |
| **ENS**            | Ethereum wallet (connection)  | Ethereum provider lookup to verify ENS records (e.g. ethers.js `lookupAddress`) or ENS smart contract queries. | (No API keys required) Optionally, a specific ENS domain or criteria (if the admin wants to require a particular domain ownership or any ENS name). |
| **EFP (Follow)**   | Ethereum wallet (transaction) | On-chain transaction to follow an address (Ethereum Follow Protocol); use Ethereum Identity Kit’s **Follow button** or call EFP contracts; verify follow via EFP API or contract state. | Target Ethereum address (or ENS name) that the user should follow; (No API key needed, uses blockchain) possibly an RPC endpoint if not using user’s wallet provider. |
| **Gitcoin Passport** | Ethereum wallet (SIWE recommended) | Gitcoin Passport API (HTTP REST) to fetch user’s **trust score** and stamps, using an API key and Scorer ID ([Passport API v2 quick start guide – Passport XYZ](https://docs.passport.xyz/building-with-passport/passport-api/quick-start-guide#:~:text=GET%20%2Fv2%2Fstamps%2F)). | Passport API Key; Scorer ID (from Gitcoin Passport developer portal); Defined passing criteria (score threshold or required stamps). |

With this foundation, we can now delve into each service integration in detail.

## Guild.xyz Integration

Guild.xyz is a platformless membership management protocol that lets communities define roles with requirements (on-chain tokens, off-chain accounts, etc.). Integrating Guild allows the onboarding wizard to verify if a user meets certain criteria (defined in a Guild) and assign roles accordingly. For example, a community could require new members to hold a specific NFT or be part of another group; Guild can aggregate those checks.

### Integration Requirements

Technically, integrating Guild involves using its **API or SDK** to check and/or update a user’s membership status. Guild provides an official **TypeScript SDK** (`@guildxyz/sdk`) which simplifies interacting with their API ([@guildxyz/sdk - npm](https://www.npmjs.com/package/@guildxyz/sdk#:~:text=The%20Guild%20SDK%20library%20is,any%20application%20with%20this%20SDK)). The Guild API is open and **does not require an API key** for basic operations ([Guild SDK | Guild Knowledge Base](https://help.guild.xyz/en/articles/6947626-guild-sdk#:~:text=Guild%20SDK%20are%20open%20for,Why%20build%20with%20us)), making integration straightforward. Key requirements:

- **Ethereum Wallet Authentication:** Guild uses wallet signatures to authenticate users. The plugin should prompt the user to connect their Ethereum wallet. Upon connection, the user’s address is used to identify their Guild profile. The Guild SDK can generate a message for the user to sign (EIP-712 or personal signature) to prove ownership of the address.
- **Guild SDK or API:** Using the SDK is recommended. With the SDK, you create a Guild client (e.g., `createGuildClient("MyAppName")`) and then use methods like `guildClient.guild.join(guildId, signerFunction)` to attempt to join a guild ([@guildxyz/sdk - npm](https://www.npmjs.com/package/@guildxyz/sdk#:~:text=%2F%2F%20Joining%20to%20a%20Guild,id%2C%20signerFunction)), or `userClient.getMemberships(address)` to retrieve the user’s current guild memberships ([@guildxyz/sdk - npm](https://www.npmjs.com/package/@guildxyz/sdk#:~:text=%2F%2F%20Get%20a%20user%20by,get%28userIdOrAddress)). The SDK handles the API calls under the hood. Alternatively, you could use Guild’s REST API endpoints directly, but the SDK abstracts authentication and requests nicely.
- **Signature Flow:** When using the SDK, after the user connects their wallet, you create a **signer function** (e.g., via ethers.js) that the SDK will use. The first call to the Guild API for a user (e.g., join or get memberships) will likely require a signed message to prove the user’s address ([@guildxyz/sdk - npm](https://www.npmjs.com/package/@guildxyz/sdk#:~:text=A%20demo%20app%20is%20available,here%2C%20it%20shows%20how%20to)). The SDK facilitates this by providing helpers to create the signer. The signed message is sent to Guild’s API to authenticate the user’s session.
- **Guild Membership Check/Join:** In the onboarding context, you will typically want to **check if the user is a member of a specified Guild and role**. Two possible approaches: 
  - *Check-only:* Use `userClient.getMemberships(userAddress)` to retrieve all guilds/roles the user has. Then see if the target guild (and optionally role) is present.
  - *Attempt join:* Use `guildClient.guild.join(guildId, signer)` to have Guild evaluate the user against the guild’s requirements. If the user qualifies for at least one role, they will be added to that guild (on Guild’s system) ([@guildxyz/sdk - npm](https://www.npmjs.com/package/@guildxyz/sdk#:~:text=%2F%2F%20Joining%20to%20a%20Guild,id%2C%20signerFunction)). This join call essentially performs the verification: if the requirements are met, the call succeeds; if not, it will throw an error or fail.
- **No Sensitive Secrets:** Since Guild’s API doesn’t need a secret, the integration is mostly client-side apart from storing the guild ID configuration. (If you use server-side to proxy the Guild API calls, you still don’t need to manage an API key, but you would need to handle the signed message from the client.)

**Recommended libraries:** The official SDK `@guildxyz/sdk` is highly recommended for integration, as it provides built-in support for wallet connectors (with examples using wagmi, etc.) and abstracts away the HTTP calls to Guild’s endpoints. It also supports a **multi-platform Guild model** – for instance, guilds that gate both a Discord and a Telegram can be managed, though in our use-case we primarily care about verifying the blockchain requirements or membership logic. The SDK is flexible and kept up-to-date with Guild’s features.

### Admin Configuration

For an admin to enable Guild.xyz verification in the onboarding flow, they need to provide some details about their Guild setup:

- **Guild Identifier:** The admin should input an identifier for the guild to check against. Guilds on guild.xyz have a unique **guild ID** (an integer) and a URL name. Using the numeric ID is most precise. (For example, a community admin who created a guild at guild.xyz might see an ID in the URL or via the Guild dashboard.)
- **Target Role (Optional):** If the admin wants to require a specific role within that Guild, they should specify the Role ID or name. Guilds can have multiple roles (each with different requirements); by default, `guild.join` will succeed if the user qualifies for *any* role. If the admin only cares about one role, the plugin should check the membership data to ensure the user has that particular role. The Role ID can be obtained from Guild (the SDK’s membership data will include role IDs/names).
- **Guild Creation (outside scope):** The admin is responsible for setting up the guild and its requirements on guild.xyz ahead of time. This might involve connecting certain platforms (Discord, etc.) or defining NFT requirements. The plugin just interfaces with that existing guild. It’s useful to instruct the admin to ensure the guild is public or accessible (Guild allows some guilds to be unlisted or private; for the plugin to verify, the guild should be accessible via API).
- **Common Ground Role Mapping:** The admin should define which Common Ground role to assign upon successful Guild verification. For example, passing the Guild check could add a role “Verified Holder” in the CG community. This mapping (Guild -> CG role) would be configured in the plugin settings.

In summary, the admin will input something like: **Guild ID = 1234**, **Role ID = 5 (optional)**, and **CG Role = “Member”**. No API keys or secrets are needed for Guild integration, simplifying configuration.

### User Onboarding Flow

From the user’s perspective in the onboarding wizard, a Guild.xyz verification step might look like this:

1. **Connect Wallet:** The user is prompted to connect their Ethereum wallet (e.g., via MetaMask). Once connected, the plugin obtains the user’s address. For example, the UI might show a “Connect Wallet to Verify Membership” button.  
2. **Sign Verification Message:** After connecting, the plugin (via the Guild SDK) may present a message for the user to sign. This is a one-time signature to authenticate with Guild.xyz (no gas cost, just a signature). The user signs the message in their wallet.  
3. **Guild Membership Check:** The plugin calls the Guild API (through the SDK) to check the user’s guild membership. This could happen automatically after signing. If using the **join approach**, the plugin calls `guild.join(guildId)` with the user’s signature. Guild’s backend checks if the user’s wallet meets the guild’s requirements (for any role, or a specific role as configured). 
   - If the user **meets the requirements**, the join succeeds (and the user is now recorded as a member of that guild/role on guild.xyz).  
   - If the user does **not meet the requirements**, the join call will fail (e.g., returns an error). The plugin should handle this gracefully, informing the user which requirement is unmet if possible (the Guild API might return information on which requirement failed, or the plugin can fetch the guild’s requirement details via the API to show the user).
4. **Assign Role in Common Ground:** If the verification passes, the plugin assigns the configured Common Ground role to the user. This could be done by calling the Common Ground platform API or using the plugin’s context if it has access to the user session. For example, the plugin might call an endpoint like `POST /api/assignRole` with the user’s CG ID and the role slug.
5. **Feedback to User:** The user sees a success message, e.g., “✅ You have verified the required membership. Role ‘Member’ granted.” If they failed, the message might be “❌ Verification failed: You do not meet the requirements for this community’s Guild.xyz membership. (Hint: You may need to hold XYZ NFT or join ABC community.)”. The wizard can offer a “Retry” option or let them skip if the step is optional.
6. **Proceed to Next Step:** On success, the user can continue to the next onboarding step. On failure, depending on the flow design, they might be stuck until they fulfill the requirements or choose to skip (if the community allows skipping, but typically for required steps they must complete it to get the role).

Under the hood, after a success, the user’s membership data (e.g. guild and role) could also be stored in their profile for reference. But primarily, the outcome is the assignment of a CG role.

**Note:** Guild.xyz can incorporate checks like Discord role, Telegram group, or Gitcoin Passport as *requirements inside Guild*. If a community chose to use Guild as a one-stop solution, the plugin’s Guild verification inherently covers those sub-requirements. However, since we are also integrating those services separately, it’s up to the community to decide whether to use Guild’s aggregated checks or individual steps. In an onboarding flow, using Guild for on-chain verifications (tokens/NFTs) and separate steps for Discord/Telegram might offer more clarity to users.

## Discord Integration

Discord is a key platform for many communities. The onboarding wizard can verify that a user is a member of the community’s Discord server, and even check for certain roles within that server. Upon verification, a Common Ground role (like “Discord Linked”) can be assigned. Integrating Discord involves using OAuth2 for user login and potentially Discord’s bot API for checking guild membership or roles.

### Integration Requirements

The integration has two parts: **Discord OAuth2 authentication** of the user, and **Discord API calls** to verify server membership or roles. Key requirements and steps:

- **Discord OAuth2 Login:** The plugin needs a Discord **OAuth2 application** (managed via the Discord Developer Portal). This provides a Client ID, Client Secret, and redirect URI for the OAuth flow. The plugin will direct the user to the Discord auth URL where the user logs in and authorizes the requested scopes. Upon success, Discord redirects back with an authorization code that the plugin exchanges for an access token.
- **Scopes and Data:** The Discord OAuth scopes determine what data you can access. At minimum, use the `identify` scope to get the user’s Discord ID and username. To check guild membership, include the `guilds` scope, which returns the list of guilds (servers) the user is a member of ([google chrome extension - Discord OAuth2 getting user roles from exact guild - Stack Overflow](https://stackoverflow.com/questions/69518877/discord-oauth2-getting-user-roles-from-exact-guild#:~:text=I%20am%20using%20discord%20,How%20can%20I%20do%20it)) ([google chrome extension - Discord OAuth2 getting user roles from exact guild - Stack Overflow](https://stackoverflow.com/questions/69518877/discord-oauth2-getting-user-roles-from-exact-guild#:~:text=Not%20really%20sure%20but%20try,guild_id%3E%2Fmembers%2F%E2%80%A6)). However, note that the `guilds` list from OAuth is a **static snapshot** and does not include role information, only basic info for each server the user is in. It also might exclude guilds where the user has disabled certain data sharing. For more detailed info (like roles or real-time membership), a bot token is needed (see below).
- **Discord Bot (optional but recommended):** Because OAuth alone cannot reveal which **roles** a user has in a server (and in some cases might not even guarantee membership info if the guild is not in the OAuth list), many integrations use a Discord **Bot** in the server to query membership. By adding a bot to the Discord server with the appropriate permission (the bot needs `Server Members Intent` enabled to read member info), the plugin can use the bot’s **Bot Token** to call Discord APIs like `GET /guilds/{ServerID}/members/{UserID}`. This returns the member object which includes an array of role IDs the user has in that server. Discord’s API requires a bot token for that endpoint (user tokens from OAuth won’t work for guild member details) ([Discord Roles - Accessing - Auth0 Community](https://community.auth0.com/t/discord-roles-accessing/53219#:~:text=Discord%2C%20I%20was%20aiming%20to,attach%20it%20to%20the%20profile)). 
  - Using a bot token in the plugin means the token must be stored securely (never exposed to the client). The plugin’s backend (server-side code) would handle any calls to Discord with this token.
- **Membership Verification Methods:** Two approaches:
  1. *OAuth-Only Method:* After OAuth login, get the user’s guild list from `/users/@me/guilds`. Check if the target Server ID is in that list. This tells you the user is a member of the server (at the time of OAuth). If you only care about membership (not specific roles) and want to avoid needing a bot, this approach can suffice. Keep in mind the data might become stale if the user leaves the server later, but for one-time onboarding it’s fine.
  2. *Bot API Method:* Use the bot token to query the server for that user’s membership/roles. This requires the user’s Discord ID (available from OAuth’s `identify` scope or the sub of the ID token if using OIDC). The plugin can call the endpoint `/guilds/{ServerID}/members/{UserID}` with an **Authorization: Bot <token>** header. A successful response means the user is currently in the server; if the user isn’t in the server, this returns 404. The response JSON includes the user’s roles in that server. This method is more robust and allows role checking. It does, however, require the admin to set up a bot and share its token.
- **Role Verification (Optional):** If the admin wants to verify that the user has a specific Discord role (for example, only users who are “Verified” in Discord get a CG role), the plugin must use the bot API method to fetch the roles array and then check for the presence of the required Role ID. The Discord Role ID would be configured by the admin. **Important:** Ensure the bot has permission to read member roles (which it will if it has the members intent and is in the server).
- **OAuth Library:** Use NextAuth’s Discord provider or a similar library to simplify OAuth token exchange and retrieval of profile data. NextAuth can handle the redirect and token exchange, providing you with a session that contains the Discord user’s info and access token. If not using NextAuth, you can manually implement the OAuth code exchange in a Next.js API route using Discord’s token endpoint.

**Security consideration:** If using a bot token, treat it like a password. Only call Discord’s API from the server side. The user’s OAuth access token can be considered short-lived and scoped, but still keep it server-side if possible (or use it immediately to fetch data then discard). In many cases, you don’t need to store the user’s Discord token at all after using it to check guild membership.

### Admin Configuration

To set up Discord integration, the community admin needs to do the following:

- **Discord Application:** Create an OAuth2 application on the Discord Developer Portal (if the plugin developer hasn’t provided a multi-tenant app). This involves:
  - Registering a new application, giving it a name (e.g., “CommonGround Onboard”).
  - Adding a Redirect URI that points to the plugin’s callback endpoint (e.g., `https://yourdomain.com/api/auth/callback/discord` if using NextAuth, or a custom route).
  - Obtaining the **Client ID** and **Client Secret** from the portal.
  - (Optionally) adding a bot user to the application if using the bot method. After creating the bot, copy its **Bot Token** and **invite the bot** to the community’s server. The bot should have the “Read Members” intent enabled in the developer portal settings, and the admin should give it access to the server (e.g., by assigning a role to the bot with the necessary permissions or simply having it as an administrator if appropriate).
- **Server and Role IDs:** Provide the **Server (Guild) ID** of their Discord server. This is a numeric ID (snowflake) that can be obtained by enabling Developer Mode in Discord and right-clicking the server to “Copy ID”. If role-specific verification is desired, also provide the **Role ID** to check. The admin can copy a role ID by right-clicking the role (with developer mode on). The admin should ensure the bot (if used) has access to see members with that role (generally if the bot is in the server, it can see all roles unless there are specific restrictions).
- **Scope Selection:** In configuration, the admin might indicate whether to use “just membership” or “membership + role” verification. This could toggle whether a Role ID is required.
- **Common Ground Role Mapping:** Decide which CG role to grant on successful Discord verification (e.g., “Discord Member” or “Verified Discord”). This is configured in the plugin’s role mapping.
- **Providing Credentials to Plugin:** The admin will input the Discord Client ID, Client Secret, and Redirect URI into the plugin settings (or these might be set globally by the plugin developer if one app is used for all communities – in that case the admin might not need to provide these). If a bot is used, the Bot Token is also input (securely). These should be stored server-side by the plugin.

In short, the admin’s checklist might look like: 

- Create Discord App -> Get Client ID/Secret.
- (Optional) Create Bot -> Get Token, invite to server.
- Provide Server ID (and Role ID if needed).
- Map to CG role “X”.

### User Onboarding Flow

During onboarding, the Discord verification step proceeds as follows for the user:

1. **Login with Discord:** The user clicks a “Login with Discord” button. This redirects them to Discord’s OAuth2 authorization page. They will be asked to authorize the application to “Access your username and avatar” (for identify scope) and “Know what servers you’re in” (for guilds scope). If the flow also wants to add the user to the server automatically, the `guilds.join` scope would be requested, which will ask for permission to join the user to a server.
2. **(Optional Auto-Join):** If `guilds.join` is used and the bot is in the server, Discord can directly add the user to the server as part of the OAuth flow. This requires that the bot has the appropriate permissions (the user will see a prompt like “Authorize app to join you to ServerName”). This is an optional enhancement: it allows a user who isn’t in the Discord server yet to be added without leaving the onboarding. If this is configured, the admin must have set the bot’s invite properly in the OAuth application (select the server in the OAuth consent dialog). After OAuth, the user will be in the Discord server automatically.
3. **Redirect Back & Token Exchange:** After granting permission, Discord redirects back to the plugin (to the specified callback URL) with an authorization code. The plugin’s backend exchanges this code for an access token (and a refresh token, if requested). Now the user is authenticated with Discord.
4. **Fetch User Guild Data:** The plugin uses the Discord access token to fetch the user’s guild list from the Discord API (GET `/users/@me/guilds`). The response will include guild IDs and basic info for each guild the user is a member of. The plugin checks if the configured Server ID matches any in this list. 
   - If found, the user is indeed a member of the server (or has just been added via guilds.join).
   - If not found, the user is not a member. In that case, if auto-join wasn’t used, you can prompt: “You need to join the Discord server to continue.” Perhaps provide an invite link to the server and a “Retry” button after they join.
5. **Fetch Role Data (if needed):** If a specific Discord role is required, the plugin now needs to check the user’s roles. Since the OAuth token cannot fetch roles, the plugin should now use the **bot token** on the server side. It will call `/guilds/{ServerID}/members/{UserID}`. If the user is in the server, this returns a JSON with the user’s info in that server, including `"roles": [<role_ids>]`. The plugin then checks if the required Role ID is in that array.
   - If yes, the user has the role.
   - If no, the user is in the server but doesn’t have the required role. The plugin should inform them: “You are a member of the server, but you don’t have the required role **XYZ**. Please contact a moderator or fulfill the criteria to get that role, then try again.” (The specifics depend on what the role represents; e.g., maybe they need to react to a Discord message to get the role).
6. **Assign CG Role:** If the membership (and role, if applicable) verification passes, the plugin grants the user the configured CG role (e.g., updates their profile to mark Discord verified). This likely involves a server-side call to CG’s system, similar to the Guild step.
7. **Feedback:** Show success or failure to the user. On success: “✅ Discord account verified. You have joined the Discord server.” On failure, instructions as mentioned (join server, or get role).
8. **Continuation:** Proceed to next step if successful. If not, possibly allow retry after the user fixes the issue. 

During this flow, the user essentially links their Discord account with their Common Ground identity. The plugin could store the Discord user ID in the user’s profile for future reference (so you know which Discord user corresponds to which CG user). This could enable features like later checking if they leave the server, but that’s beyond onboarding.

**Edge cases:** If the user already logged in via Discord in a previous session, you could detect that and skip re-auth (if you stored a persistent link). But generally, each onboarding likely asks anew for clarity. Also, if the user revokes the OAuth or leaves the server after onboarding, the CG role might become stale; the community should decide how (or if) to periodically reconcile Discord membership, but that’s outside the immediate flow.

## Telegram Integration

Telegram is another common community platform. The onboarding plugin can verify that a user is in a specific Telegram group or channel. Since Telegram doesn’t have a traditional OAuth2 for general use, the integration uses Telegram’s **Login Widget** for authentication and the **Telegram Bot API** to check group membership.

### Integration Requirements

Technical steps for Telegram integration:

- **Telegram Login Widget:** Telegram provides a JavaScript widget that can be embedded on a webpage for login. It uses Telegram’s existing user session (or prompts the user via the Telegram app) to authorize your website. The widget returns the user’s Telegram basic profile info (ID, first name, username, etc.) along with a cryptographic **hash** to verify the data. To use it, you must have a Telegram **Bot** and use the bot’s username in the widget initialization. The widget will call a callback function in your page with an object containing the user data and the hash. The plugin should verify this hash using the bot’s token to ensure the data is authentic (Telegram’s docs provide a formula: essentially an HMAC with the token as the key over the data fields).
- **Telegram Bot:** A Telegram bot is required, not for OAuth, but for membership checking and for the login widget. The admin (or plugin developer) must create a Telegram Bot via BotFather (which provides a **Bot Token**). The bot’s username is used to configure the login widget (for example, `TelegramLoginWidget.init({ bot_id: ..., onAuth: onTelegramAuth })`). The bot token is used server-side to call Telegram APIs.
- **Membership Verification via Bot API:** Once the user’s identity is obtained from the widget (you get their Telegram **user ID**), the plugin uses the **Bot API** method `getChatMember` to check if that user is a member of the specified group. The plugin will call: `https://api.telegram.org/bot<BotToken>/getChatMember?chat_id=<GroupID>&user_id=<UserID>`. The response will contain a `status` field indicating the user’s status in the group ([How can I check whether a user is a member of a Telegram group?](https://stackoverflow.com/questions/49545889/how-can-i-check-whether-a-user-is-a-member-of-a-telegram-group#:~:text=How%20can%20I%20check%20whether,status%20for%20member%2C%20left%2C%20etc)). Possible values include “member”, “administrator”, “creator” (if they are in the group) or “left”, “kicked” (if they are not). If the status shows they are currently a member (or admin/creator), verification passes.
- **Group Identification:** Telegram groups (and channels) have identifiers. Public groups have a username (e.g., `@communitygroup`) which can be used in place of chat_id. Private groups have a numeric ID, typically a large negative number (for supergroups) or just a number. The admin will supply this. The bot needs to be added to that group. If the group is private, simply adding the bot is enough for it to use getChatMember. If it’s a channel (broadcast channel), note that channels don’t list users via getChatMember unless the user has posted, so it’s better to use groups or supergroups for this purpose.
- **No direct OAuth:** The Telegram login widget essentially acts as an OAuth (the user consents to share their Telegram info with the site). The advantage is it’s quick and uses their Telegram session. The disadvantage is it only authenticates identity, not group membership, so we need the bot API for the second part. There is no “single-click” way to verify group membership without the bot, because Telegram doesn’t expose “which groups a user is in” publicly due to privacy.

**Libraries:** You can use Telegram’s official script. There are also some community libraries (e.g., for React, but it’s simple to just include the script in a Next.js component). Verification of the hash can be done with a small piece of code (Telegram provides examples in many languages). For making Bot API calls, you can use a standard HTTP client (fetch/axios) from your server. The Bot API is a simple JSON HTTP API.

### Admin Configuration

For Telegram integration, the community admin must provide:

- **Telegram Bot Token:** The string that identifies their bot and allows API calls (format: `123456:ABC-DEF...`). The admin creates a bot with BotFather and obtains this token. They should keep it secret and input it into the plugin’s settings.
- **Telegram Group or Channel ID:** The identifier of the Telegram group the community uses (for example, a group where all members chat or an announcements channel). If it’s a public group with a @username, the admin can provide that (the plugin can internally convert it to an ID by calling `getChat` method or just use the username directly in `getChatMember`). If it’s private, the admin might need to get the numeric ID. They can do this by temporarily adding another bot or using Telegram’s export chat invite link (some methods exist, or the plugin could help derive it by using the bot: the admin could press a “Test” button that calls an API to fetch the chat ID using the provided token and an invite link).
- **Add Bot to Group:** The admin must **add the bot to the Telegram group** (and ideally give it permission to see messages, though to just use getChatMember, the bot doesn’t need to be admin; being a regular member is sufficient to query membership status in that group).
- **Common Ground Role Mapping:** Choose the CG role that will be granted when a user verifies their Telegram membership (e.g., “Telegram Linked”).
- **Bot Username:** The admin should also provide the bot’s username (e.g., `MyCommunityBot`) because the front-end needs it to initialize the widget (though in many cases you can derive the bot’s username by calling `getMe` on the Bot API with the token, it might be simpler to ask for it).
- Optionally, if the admin wants the plugin to display a **join link** for the Telegram group (in case the user isn’t a member yet), they could provide an invite link or the public group username which the plugin can use to direct the user. For example, the plugin could show “Join our Telegram group @GroupName, then click verify.” If the group is public, the @GroupName link is enough; if private, an invite link (t.me/joinchat/...) might be needed.

In summary, the admin provides: **Bot Token**, **Group ID or username**, (possibly Bot username), and sets which CG role to assign.

### User Onboarding Flow

For the user, the Telegram verification step would proceed like this:

1. **Initiate Telegram Login:** The wizard page loads the Telegram Login Widget. It may be a button saying “Login with Telegram” or an embedded frame. When the user clicks it, if they are logged in to Telegram (web or mobile), it will ask them to authorize sending their Telegram profile data to the plugin. This usually appears as a popup showing their Telegram name and asking for confirmation.
2. **User Authorizes:** Once the user accepts, the widget provides the plugin (client-side) with the user’s Telegram information: their **Telegram user ID**, first name, last name, username (if they have one), and a **hash** that signs this data. For example, the JavaScript callback receives an object: `{id: 12345678, first_name: "Alice", username: "AliceInTG", photo_url: "...", auth_date: 1672531199, hash: "abcdef..."}`
3. **Verify Auth Data:** The plugin (client-side or via an API call) verifies the hash using the shared secret (bot token). This is to ensure the data wasn’t tampered with. If the verification fails (which is rare if using Telegram’s official widget correctly), it should reject the login. Assuming it passes, the user is now authenticated as Telegram user ID 12345678.
4. **Check Group Membership:** Now the plugin uses the **bot token** to call `getChatMember` for the configured group and the user’s ID. This happens on the server side (the plugin sends the user’s Telegram ID in a secure request to its backend, the backend uses the bot token to query Telegram). The API returns something like `{"ok": true, "result": {"status": "member", "user": {...}}}` if the person is in the group. Possible outcomes:
   - *Member:* If `status` is `"member"` (or `"administrator"` or `"creator"`), the user is part of the group. Success!
   - *Not a member:* If `status` is `"left"` or `"kicked"` (or the API returns an error that the user is not found), then the user is not in the group currently.
   - If the group is actually a **channel** and the user never posted or interacted, Telegram might return an error for getChatMember because in channels the bot can only check if someone has explicitly joined if it knows about them. But for standard groups, it will work as long as the bot is present.
5. **Prompt to Join if Needed:** If the check says the user isn’t in the group, the plugin should inform them: “It looks like you are not a member of the Telegram group **GroupName**. Please join the group and then click Retry.” If the admin provided a join link or the group is public, you can embed that link for convenience (e.g., a button “Join Group” that opens `https://t.me/GroupUsername`). The user then needs to join the Telegram group manually in their Telegram app.
6. **Retry Verification:** The user comes back and clicks a “Verify Membership” button (which just re-triggers the getChatMember check, since the plugin already knows their Telegram ID from step 2 and still has a session). Alternatively, you might have them go through the login widget again which will yield the same ID and you check again. On the second attempt, if they have joined the group, `getChatMember` should return status “member”.
7. **Assign Role:** If membership is confirmed, the plugin assigns the configured CG role to the user (e.g., adds “Telegram Member” role to their profile).
8. **Feedback:** Show a success message like “✅ Telegram account verified and group membership confirmed.” If after retry it’s still failing, let them know verification didn’t succeed (and perhaps allow skip if non-mandatory).

From the user's perspective, this flow requires that they **have a Telegram account** and join the Telegram group. The integration is fairly smooth since the login widget handles authentication in one click. The potential friction is the need to join the group, but many users likely joined via a link beforehand; if not, the step prompts them to do so.

**Under the hood:** The plugin might store the Telegram user’s ID and username in the user's profile for record-keeping (so the community mods can know Telegram handles of users). The Telegram user ID is a numeric ID that could be used later if, for example, the CG platform wants to send a message via the bot to the user (not usually needed, but possible).

## ENS Integration

Ethereum Name Service (ENS) is often used as a decentralized identity (e.g., having an ENS name means the user has a recognizable domain like alice.eth). Communities might want to verify that a user has an ENS name, or a specific ENS domain (perhaps related to the community). In the onboarding context, ENS verification could be used to ensure the user has set up an ENS profile or owns a certain NFT domain.

### Integration Requirements

ENS integration is entirely on-chain and does not require any OAuth or third-party API beyond an Ethereum JSON-RPC. Key technical requirements:

- **Ethereum Provider:** The plugin will use an Ethereum provider (like Infura, Alchemy, or the user’s own wallet provider) to query the ENS records. Since the plugin already likely has the user’s wallet connected (from a Guild or EFP step), it can reuse that connection or use a read-only provider.
- **ENS lookup:** To verify a user’s ENS, the typical check is to see if the user’s address has a **primary ENS name** set (also called Reverse Record). This is the name the user has designated as their ENS name for that address. Using ethers.js, this is a single call: `provider.lookupAddress(userAddress)`, which returns the ENS name if the reverse record is set ([reactjs - How to get ENS name from specific wallet address in react - Stack Overflow](https://stackoverflow.com/questions/73211191/how-to-get-ens-name-from-specific-wallet-address-in-react#:~:text=await%20provider.lookupAddress%28)). If it returns null, the user either doesn’t have an ENS name or hasn’t set their primary name in ENS.
- **Specific Domain Ownership (optional):** If the requirement is to verify ownership of a particular domain (e.g., the community might only allow users who own an ENS under a certain subdomain like `*.community.eth`), then the plugin needs to check if the user’s address is the owner of that ENS domain. This can be done by querying the ENS registry. For example, using ethers.js: `provider.resolveName("username.community.eth")` would give an address if that name exists, and then compare with the user’s address. Alternatively, one can use the ENS registry contract to get the owner of the namehash of the domain and match it.
- **ENS contract interactions:** In most cases, **no transaction is needed**. We are only reading data. If a user does not have a primary ENS name set, and the community requires one, the user would have to go and set it themselves (which is an on-chain transaction they do outside the plugin, likely via an ENS manager dApp). The plugin will just detect the presence or absence of ENS data.
- **Libraries:** Use **ethers.js** with an ENS-enabled provider (Mainnet Ethereum). Ethers automatically supports ENS on mainnet; if using other networks, ensure to use mainnet for ENS resolution calls. Another library is the ENS.js library, but it’s not necessary for just lookup. Ethers or web3 will suffice.
- **No API keys:** ENS queries can be done through public RPC endpoints or the user’s wallet. If using the user’s wallet provider (like MetaMask’s provider), ensure you call `lookupAddress` on mainnet. If the user is connected to a different chain at that time, you may need to use a fallback Infura/Alchemy call to mainnet for the ENS query.
- **Alternate checks:** Some communities might instead want to verify that the user *owns any ENS domain*. Owning an ENS name means the user’s address is the owner of at least one name in the ENS registry (not necessarily set as primary). To check that generally is harder without an index, but one heuristic: query the **ENS NFT contract** balance for the user. The .eth names are ERC-721 tokens in the ENS ETH Registrar (contract `0x57f1887a...`). You could do `balanceOf(userAddress)` on that contract to see if they hold any .eth name token. If >0, they own at least one name. For more detail, you’d then query which name, but just the existence might be enough for “has any ENS”.
- **ENS Content or Text Records (optional):** In some advanced cases, a community might require the user’s ENS profile to have certain records (like an avatar or Twitter verification in text records). This is probably beyond scope – likely we just care about existence of a name. But if needed, one could use the ENS resolver to fetch text records (like `getText(name, "twitter")`) to verify something.

### Admin Configuration

ENS integration is relatively simple to configure:

- **ENS Requirement Type:** The admin should specify what aspect of ENS to verify. Two common configurations:
  - *“Any ENS name”:* Just check the user has a primary ENS set (i.e., any name). This might be the default if the admin enables ENS step without further detail. It indicates the user has an ENS identity.
  - *“Specific ENS Domain”:* The admin provides a particular ENS domain (or pattern). For example, **Domain = `mycommunity.eth`** might mean the user must own `mycommunity.eth` or a subdomain of it, depending on the intention. Or they might provide **Subdomain = `member.mycommunity.eth`** to check if the user owns that exact name (maybe they issue subdomains to verified members). The plugin could be built to handle a wildcard like `*.mycommunity.eth` to mean any subdomain under that. However, implementing wildcard checking would require some pattern match or an API query. If an exact name is given, just check that.
  - If the requirement is just a yes/no for “has any ENS”, no extra input beyond enabling is needed.
- **Common Ground Role Mapping:** Choose which role to assign if the ENS check passes (e.g., “ENS Holder” or “ENS Verified”).
- **No API keys or tokens:** The admin does not need to provide anything like RPC keys; the plugin will use its built-in provider or a global one. However, if the plugin is self-hosted and the developer expects an Infura or Alchemy key for ENS queries, that could be set in environment variables (global config, not per admin).
- If checking a **specific domain for ownership**, the admin needs to supply that domain name string. If checking **any ENS name**, maybe allow admin to set a flag (but likely just if they add the ENS step without specifying a domain, it implies any name).
- Possibly, an admin might say “ensure they have an ENS name that ends with .eth” (which is basically any normal ENS) – since ENS also covers other TLDs like .xyz via namewrapping, but that’s edge. Assuming .eth primarily.

In most cases, configuration is minimal: an on/off for “ENS verification required” and an optional field for “required ENS name (or suffix)”.

### User Onboarding Flow

The ENS verification step is straightforward for the user:

1. **Connect Wallet (if not already):** The user needs to have their Ethereum wallet connected. If they already did this in a prior step (Guild, EFP, Passport), the plugin should reuse that connection and address. If not, it prompts now. No extra signing is needed for just reading ENS.
2. **ENS Query:** The plugin looks up the ENS information for the user’s address:
   - If the requirement is **any ENS name**: The plugin calls `lookupAddress(userAddress)` via ethers. If this returns a non-null name (e.g., it returns “alice.eth”), that means the user has set an ENS primary name. The plugin can further verify by doing a reverse check (optional: resolve that name back to address to ensure consistency, but `lookupAddress` should already ensure it’s correct). If a name exists, success. If it returns null, then failure (user has no ENS name set).
   - If the requirement is **specific ENS**: The plugin will resolve that name to an address and compare to the user’s address. For example, admin said required ENS = “alice.community.eth”. The plugin calls `resolveName("alice.community.eth")` -> gets some address. If that matches `userAddress`, then the user owns that ENS name (or is pointed to them, which generally implies ownership if they set it; though caution: resolveName returns the “addr” record, which the owner of name can set to any address. A more secure check of ownership is using the ENS registry `owner(namehash)`, but that would require a separate call. It might be okay to assume if the user has control, they’d set it to themselves. For strictness, doing an owner lookup via the ENS registry contract is best).
   - If the requirement is **ensuring they have at least one ENS** (but not necessarily set as primary): The plugin might do the ERC-721 balance check. If `balanceOf(userAddress)` on the ENS .eth registrar > 0, they own an ENS name. (This wouldn’t catch subdomains as those aren’t separate NFTs, but usually subdomains aren’t considered “owned” by the user unless the community specifically gave them).
3. **Result Handling:** 
   - If the ENS condition is satisfied, the plugin marks this step as complete. Possibly it could even display the ENS name the user has (like “Detected ENS: alice.eth”) to confirm to the user.
   - If not satisfied, the plugin informs the user: “No ENS name found for your address.” or “You do not own the required ENS domain.” Provide instructions if needed: For example, “To complete this step, you need an ENS name. You can register one at ens.domains and set it as your primary name, then come back and verify.” If a specific name is needed, the instruction would be more specific (“You need to own **mycommunity.eth** to pass this step.” which likely means they can’t easily get it unless the community gave it to them, so maybe a specific ENS requirement would be used if the community pre-issued subdomains).
4. **Assign Role:** On success, assign the configured role (like “ENS Verified”).
5. **Feedback:** Show success message, e.g., “✅ ENS name detected: alice.eth. Role granted.” or on failure, perhaps allow them to skip if it’s optional, or just leave it as incomplete.

Because ENS is an optional identity layer, some communities might not strictly require it – they might include it as an optional step that gives a bonus role or just for user’s personalization. The plugin can support skipping if the admin marks it non-mandatory.

From a development standpoint, ENS checks are instantaneous (just RPC queries). One thing to remember is to handle network issues – if the RPC call fails, handle that (maybe retry or show error). But no user interaction beyond possibly connecting to mainnet is needed. If the user’s wallet is on another chain, you might either ask them to switch to mainnet to do the lookup via their provider, or just use a backend provider to avoid that requirement.

Finally, if a user has multiple addresses or something, we consider only the address they connected. It’s possible a user has an ENS name on one address but they connected with a different address. They would fail in that case. The instructions could clarify: “Make sure you connect the wallet that holds your ENS name.”

## Ethereum Follow Protocol (EFP) Integration

Ethereum Follow Protocol (EFP) is an on-chain social graph that lets Ethereum addresses “follow” other addresses (similar to following on Twitter, but on Ethereum). Integrating EFP means we can require a user to follow a specific Ethereum account (for example, the community’s official address) as part of onboarding. Once the user follows on-chain, we verify it and assign a role (perhaps like “On-Chain Follower” or to indicate a deeper engagement).

### Integration Requirements

EFP integration involves on-chain transactions and/or interactions via provided libraries:

- **Ethereum Wallet:** The user must use an Ethereum wallet for this step (just like for Guild or ENS). They will actually need to perform a transaction if they haven’t already interacted with EFP. Specifically, following someone via EFP means adding that address to the user’s following list on-chain.
- **EFP Contracts and Actions:** Under the hood, every user who participates in EFP mints a “Follow List NFT” that represents their list of followed accounts ([Introduction | EFP Docs](https://docs.efp.app/intro/#:~:text=EFP%20List%20NFT)). To follow an account:
  1. If the user hasn’t minted their EFP List yet, they must do so (minting is free aside from gas ([Introduction | EFP Docs](https://docs.efp.app/intro/#:~:text=Users%20mint%20an%20EFP%20List,to%20create%20an%20EFP%20List))). This could be triggered automatically when they attempt to follow the first time.
  2. Then, the user (as the “Manager” of their list) adds a record for the target address to their list (another transaction).
- **EFP Identity Kit / SDK:** The EFP team provides an **Ethereum Identity Kit** and potentially an SDK or example components to simplify integration. For instance, they mention an embeddable **Follow Button** ([Integrations | EFP](https://efp.app/integrations#:~:text=)) that developers can drop in. This button likely handles checking if the user is already following and if not, prompts a transaction to follow (including the initial NFT mint if needed). Using such a ready-made component or the EFP API could save time. The identity kit also offers a **Public API** to query follow relationships (e.g., to check if user A follows B).
- **Custom Implementation:** If not using the kit, you’d use **ethers.js** to interact with EFP’s contracts. The EFP documentation provides contract addresses and ABI for the List registry and list records. Essentially, after wallet connect:
  - Check if the user already has a list. This could be done by calling a function like `getPrimaryList(address)` (EFP likely has a way to get a user’s list token ID if exists). Or call the List NFT contract to see if `balanceOf(user)` > 0.
  - If no list, call the List NFT contract’s `mint()` function to create one (the user pays gas; EFP might design this to be minimal cost).
  - Then call the List Records contract to “add follower”: something like `addFollower(listId, targetAddress)` (the exact contract method might differ, but conceptually).
  - These are transactions requiring the user to confirm in their wallet.
- **Public API verification:** Instead of reading the chain directly to confirm follow, you can query EFP’s API. The EFP Public API (hosted at `ethidentitykit.com`) has endpoints to get who a user is following ([Integrations | EFP](https://efp.app/integrations#:~:text=Start%20showing%20your%20users%20the,pulling%20who%20they%20follow%20onchain)) or check follow status. For example, a hypothetical `GET /v1/following?follower=<user>&followed=<target>` could return true/false. If using their JS kit, they might even offer a hook like `useFollowingState(user, target)` ([Ethereum Identity Kit](https://ethidentitykit.com/docs/api#:~:text=,21)) ([Ethereum Identity Kit](https://ethidentitykit.com/docs/api#:~:text=,Primary%20List)). Using the API avoids writing custom chain parsing, but one must trust the API. Since it’s just reflecting on-chain state, it’s likely fine, and avoids needing an Ethereum RPC call on your own.
- **Gas considerations:** Because following is an on-chain action on Ethereum, users will have to pay gas fees. This is important to communicate to the user. If your community expects this to be done on mainnet, the user will incur a (hopefully small) gas fee. If that’s a concern, perhaps this step is optional or can be done on a Layer2 if EFP supports it (the EFP docs mention L2 storage locations ([Introduction | EFP Docs](https://docs.efp.app/intro/#:~:text=List%20Storage%20Location)), possibly meaning the follow data could be on L2).
- **Target address or list:** The admin likely specifies one Ethereum address that users should follow (e.g., the community’s ENS name or treasury address). But EFP could theoretically allow requiring to follow multiple addresses. Our integration will assume one target per step for simplicity. If multiple follows are wanted, each could be a separate step or a custom logic to check a set.

### Admin Configuration

For EFP integration, the admin needs to provide:

- **Target Ethereum Account:** The address (or ENS name) that users are required to follow. For example, the community’s main address or an influencer’s address relevant to the community. If an ENS name is provided, the plugin should resolve it to an address for the actual follow call.
- **Common Ground Role Mapping:** The role to assign when a user has successfully followed the target. For instance, if the community’s address is followed, maybe give a role “Community Follower” or similar.
- **Optional EFP details:** The admin might not need to provide anything else because the heavy lifting (contracts, etc.) is standardized. They don’t need API keys (EFP is decentralized). If the community specifically uses a custom EFP list or something (perhaps they want the user to follow a list of multiple accounts?), they would have to specify those. But likely it's just one account.
- Possibly an option to choose *how* to verify (via on-chain directly or via EFP API) could be a developer decision rather than admin config.

Since EFP is relatively new, the plugin developer should keep an eye on EFP documentation for any required API keys or changes. As of now, the design is that no keys are needed – it’s open. The admin’s main job is just telling who to follow.

### User Onboarding Flow

The user experience for the EFP follow step will be the most “web3-native” one, involving signing and transactions:

1. **Connect Wallet:** If not already connected, user connects their Ethereum wallet (very likely they did in a prior step, so this is reused).
2. **Check Current Follow Status:** The plugin should check if the user’s address already follows the target address via EFP. It’s possible the user is already using EFP and has followed that address in the past. To do this, use either the EFP API or a contract call. For example, call EFP API `/followers?address=<target>&page...` to see if user is in the list of followers of the target, or check the user’s following list for the target. If this check returns true, then the plugin can skip the follow action and mark it as complete (“You already follow this address on-chain.”). If not, proceed to next step.
3. **Prompt Follow Action:** The plugin will present the user with a prompt like “Follow [CommunityName] on Ethereum to continue.” Perhaps with a brief explanation that this will create an on-chain connection. If using the identity kit’s **Follow Button**, this might be a ready UI component. On clicking it, one of two things can happen:
   - If the user has not minted an EFP list yet, the component/logic will initiate the **mint transaction**. The user’s wallet will pop up asking to confirm creating their Follow NFT (costing gas). After confirming, wait for transaction success.
   - Then a second transaction to **add the follow record**: wallet pops up again to confirm following the target address (this could be a call on the list contract). User confirms.
   - If the user already had the list (minted before, maybe via another app or following someone else), then only the second transaction is needed.
   - It’s possible EFP might optimize this to a single transaction in the future or batch, but currently likely two.
4. **Transaction Handling:** The plugin should show a loading indicator like “Awaiting confirmation...” and then “Transaction in progress...”. After each transaction, you might wait for it to be mined (listen to provider events or use ethers to wait).
   - If the user rejects a transaction or it fails (runs out of gas, etc.), handle that gracefully (allow retry or cancellation).
5. **Verify Follow:** Once the transactions are confirmed, the user should now be following the target on-chain. The plugin then verifies the follow was successful. For example, query the EFP API for the follow state again, which should now indicate true. Or one could assume success if the tx didn’t revert. But a final check is good practice: call `getChatMember` equivalent in EFP context, i.e., ask “does user follow target now?” via API or contract. The Ethereum Identity Kit likely provides a hook or function for this, such as `useFollowerState` ([Ethereum Identity Kit](https://ethidentitykit.com/docs/api#:~:text=%2A%20SIWE%20Button%20,Soon)) or an API endpoint ([Integrations | EFP](https://efp.app/integrations#:~:text=Start%20showing%20your%20users%20the,pulling%20who%20they%20follow%20onchain)) to list followings.
   - If the check passes, proceed. If somehow it doesn’t (perhaps the tx hasn’t been mined fully or indexed by the API), you might either wait a few seconds and retry, or trust the tx and proceed anyway. Since it’s on-chain, a pending tx that’s been broadcast should be sufficient, but confirming ensures it’s final.
6. **Assign Role:** Mark this step complete and assign the CG role (e.g., “On-chain follower”).
7. **Feedback:** Show “✅ You have followed the required address on Ethereum.” Possibly even display the followed ENS or address to reinforce what they did (“Followed: community.eth”). If the user’s wallet had to do two transactions, acknowledge completion after both.
8. **Next Step:** Continue onboarding.

Throughout this process, **user guidance is important** because performing on-chain actions can be confusing to non-crypto-native users:
- If gas fees are high, warn them. If EFP supports multiple networks, perhaps choose a cheaper network (but likely it’s mainnet to tie into ENS, etc., as EFP “complements ENS and SIWE” ([Integrations | EFP](https://efp.app/integrations#:~:text=Ethereum%20Follow%20Protocol%20,and%20Sign%20in%20with%20Ethereum))).
- Let them know they might see two wallet prompts.
- If they don’t have ETH for gas, they might not be able to do this immediately — the community might want to make this step optional if they realize some newcomers may not afford a tx. Alternatively, if they require it, they should be ready to help those users get a small amount of ETH for gas or provide an alternate path.

Once done, the user has an on-chain link to the community’s address. This could potentially be used later for on-chain social features (like checking mutual follows, etc., though that’s outside the plugin’s immediate scope).

In code, using the EFP Identity Kit’s follow button might be as simple as:
```jsx
<FollowButton followerAddress={userAddress} followeeAddress={targetAddress} />
```
(This is hypothetical; you’d refer to their docs for actual usage.) This component likely handles the logic described internally.

Finally, note that every EFP list is public on-chain, so anyone can later query who a user is following. But since the user explicitly consents by doing it, privacy isn’t a big concern beyond normal blockchain transparency.

## Gitcoin Passport Integration

Gitcoin Passport (now under Passport by Gitcoin) is a system where users collect verifiable credentials (stamps) from various platforms (Twitter, Google, BrightID, etc.) to build a trust score that signals they are a unique human and not a bot. Communities can use Passport to gate access (for example, requiring a minimum trust score or specific verifications). By integrating Passport, the onboarding wizard can automatically retrieve a user’s Passport score and determine if they meet the community’s criteria, then assign a role like “Verified Human”.

### Integration Requirements

The Passport integration is different from previous ones in that it doesn’t involve the user logging in to a third-party at the time of onboarding (all needed data is already in the Passport system, tied to their Ethereum address). The requirements are:

- **Ethereum Address (Wallet):** The user’s Passport is identified by their Ethereum address. So the user must connect their wallet to provide an address. Ideally, also have them sign a message (SIWE) to ensure the session is truly controlled by that wallet (though if we trust the connection from earlier steps, that might suffice). Signing is an extra security step to prevent someone from inputting someone else’s address to fetch a Passport (the API might not allow it without proof anyway).
- **Passport API Key and Scorer ID:** Gitcoin’s Passport API v2 requires an API key for access ([Passport API v2 quick start guide – Passport XYZ](https://docs.passport.xyz/building-with-passport/passport-api/quick-start-guide#:~:text=GET%20%2Fv2%2Fstamps%2F)) ([Passport API v2 quick start guide – Passport XYZ](https://docs.passport.xyz/building-with-passport/passport-api/quick-start-guide#:~:text=match%20at%20L151%20,06T14%3A28%3A06.879000%2B00%3A00)). The developer (or community admin via developer portal) must obtain this. Also, queries are made in the context of a **Scorer ID**, which represents a specific scoring schema or use-case. The Scorer defines how stamps are weighted and what the threshold for “passing” is. The admin or developer needs to set up a Scorer in the Passport Developer Portal ([Getting access to the Passport API v2 – Passport XYZ](https://docs.passport.xyz/building-with-passport/passport-api/getting-access#:~:text=Getting%20your%20Scorer%20ID)) ([Getting access to the Passport API v2 – Passport XYZ](https://docs.passport.xyz/building-with-passport/passport-api/getting-access#:~:text=If%20you%20have%20already%20selected,to%20the%20new%20format%20soon)). For example, “Unique Humanity Scorer” is recommended (which gives a score out of 100 and typically considers a score ≥20 as human ([Passport API v2 quick start guide – Passport XYZ](https://docs.passport.xyz/building-with-passport/passport-api/quick-start-guide#:~:text=humanity%20with%20Passport%20since%20their,the%20recommended%20threshold%20of%2020))).
- **Passport API endpoint calls:** The main call to use is `GET /v2/stamps/{scorer_id}/score/{address}` ([Passport API v2 quick start guide – Passport XYZ](https://docs.passport.xyz/building-with-passport/passport-api/quick-start-guide#:~:text=GET%20%2Fv2%2Fstamps%2F)). The plugin will call this endpoint with the user’s address and the community’s scorer_id. In the HTTP header, include `X-API-KEY: <API Key>` to authenticate. The response will include:
  - `score`: the numeric score the user’s Passport achieved (as a string or number).
  - `passing_score`: a boolean indicating if the score meets the default threshold set for that scorer.
  - `stamp_scores`: an object with individual scores for each stamp category ([Passport API v2 quick start guide – Passport XYZ](https://docs.passport.xyz/building-with-passport/passport-api/quick-start-guide#:~:text=,06T14%3A28%3A06.879000%2B00%3A00)) (e.g., they might have small contributions from various stamps).
  - `last_score_timestamp`, etc.
  
  For example, it might return `"score": "33.538", "passing_score": true` ([Passport API v2 quick start guide – Passport XYZ](https://docs.passport.xyz/building-with-passport/passport-api/quick-start-guide#:~:text=match%20at%20L151%20,06T14%3A28%3A06.879000%2B00%3A00)), meaning the user passed the threshold (likely 20).
- **Threshold or Criteria Evaluation:** The community can either rely on `passing_score` (which uses the scorer’s built-in threshold) or set a custom requirement. Maybe the community wants a higher bar (like score >= 50 for extra safety) or they require specific stamps regardless of score. The plugin should handle:
  - **Simple mode:** use `passing_score` directly (likely corresponds to ~20 threshold if using Unique Humanity).
  - **Custom score threshold:** compare the returned `score` to a configured value.
  - **Specific stamps (advanced):** The `stamp_scores` could be used to ensure certain stamps exist. If a stamp is missing, it might not appear in `stamp_scores` or could be zero. Alternatively, one could call another endpoint that lists the stamps the user has. In v2, that might require an additional call or might be embedded in the scoring (not sure if v2 API directly lists stamp details; v1 had a GraphQL to query stamps).
  
  If the admin says “user must have Twitter and GitHub stamps”, the plugin needs to ensure those stamps are present. Possibly the easiest way is to see if `stamp_scores` has keys like `"Twitter":` and `"GitHub":`. If they are missing or 0, then fail. (This is an approximation; a more thorough approach is using the Passport API’s stamp metadata endpoint or checking a second API like `GET /v2/stamps/{scorer_id}/passport/{address}` if it exists, or using v1 GraphQL.)
- **No user action needed at time of onboarding:** The user should have already created their Passport beforehand (on passport.gitcoin.co) and added stamps. The onboarding plugin just fetches data. If the user doesn’t have a Passport or it’s empty, their score will be 0 or null and they won’t pass. We should handle that result and possibly direct them to create a Passport.
- **Network and Data Freshness:** Passport data is stored off-chain (in Ceramic) and the score calculation is done periodically. The API might not reflect stamps added in the last few minutes. Typically, after adding new stamps, one might have to “refresh” or wait for next scoring. The plugin can only retrieve the latest stored score. If a user just created a Passport moments ago, their score might not be computed yet. This is a known limitation (score API might return an outdated result until next calc). Communicate to user if relevant: e.g., “If you just updated your Passport, it may take a few minutes to reflect. You can retry shortly.”

**Recommended Implementation:** Make the API call server-side to keep the API key secret. For instance, when the front-end knows the user’s address, it calls your Next.js API route `/api/checkPassport?address=0xABC...`. The backend uses `fetch` with the API key header to `api.passport.xyz`. This returns JSON which the backend then processes (checks score, etc.) and returns a simplified result to the front-end (like pass/fail and maybe the score).

### Admin Configuration

To enable Passport verification, the admin (or developer) must do some one-time setup in Gitcoin Passport’s system:

- **Obtain API Key:** The admin or developer goes to the [Passport Developer Portal](https://developer.passport.xyz) and logs in (with Ethereum). They create an API key ([Getting access to the Passport API v2 – Passport XYZ](https://docs.passport.xyz/building-with-passport/passport-api/getting-access#:~:text=1,to%20access%20the%20Passport%20API)). This key will be used by the plugin’s server to authenticate API requests. The admin should input this API key into the plugin’s secure config.
- **Create a Scorer:** In the Developer Portal, create a **Scorer** for the community’s use case ([Getting access to the Passport API v2 – Passport XYZ](https://docs.passport.xyz/building-with-passport/passport-api/getting-access#:~:text=Getting%20your%20Scorer%20ID)) ([Getting access to the Passport API v2 – Passport XYZ](https://docs.passport.xyz/building-with-passport/passport-api/getting-access#:~:text=If%20you%20have%20already%20selected,to%20the%20new%20format%20soon)). Likely choose “Unique Humanity” type (as recommended, since it’s the standard scoring model). Once created, note the **Scorer ID** (the portal shows it, e.g., a number or UUID in the URL). The admin inputs this Scorer ID into the plugin config.
- **Define Criteria:** The admin decides what constitutes a “pass”. If they are fine with the default threshold of the scorer, they can simply use `passing_score`. If they want to override or require specific stamps:
  - They might specify a custom **score threshold** (e.g., 25 instead of 20).
  - Or list required **stamps** (like `["Twitter","Google","BrightID"]`). The plugin would then enforce that those stamps have nonzero score.
  - The UI for admin could present a list of known stamps to choose from or a slider for score. This depends on how granular the plugin wants to be. For a first version, maybe just threshold is enough.
- **Common Ground Role Mapping:** The admin chooses a role for successful verification, e.g., “Passport Verified” or “Verified Human”. They might even have multiple levels (not in this spec, but conceivable: e.g., score >50 gives “Level 2 Verification”, etc.). But likely one role.

So the admin supplies: **API Key**, **Scorer ID**, and optionally criteria (threshold or stamps) beyond the default. The plugin developer might also have a global API key used across communities, but that’s less likely because usage limits might apply; better each community uses their own key to track usage.

### User Onboarding Flow

The Passport verification step from the user’s view:

1. **Connect Wallet:** The user must have their Ethereum wallet connected (with the address that they used for Gitcoin Passport). Usually, this is the same address they’d use for other Web3 steps. If not connected, prompt to connect. Optionally, prompt them to **sign a message** to prove they own that address (especially if this step is done independently of others). A SIWE signature or even a simple `personal_sign("I am verifying my Passport")` could be used. However, the Passport API doesn’t actually require a user signature to fetch a score – having the address and API key is enough. The signature would purely be to prevent a malicious user from supplying someone else’s address. Given this is an onboarding flow (and presumably the user is cooperative), you might skip explicit signing and trust that since they control the web session with a connected wallet, that’s fine. If extra security is needed, implement SIWE to tie their wallet to the session earlier in the flow.
2. **Fetch Passport Score:** Once the plugin has the user’s address (say `0x1234...`), it calls the Passport API (via backend). For example, GET `api.passport.xyz/v2/stamps/<ScorerID>/score/0x1234...` with the header. This returns the JSON with the score and details.
3. **Evaluate Criteria:** The plugin inspects the response:
   - If `passing_score` is true (and admin is using default threshold), then it’s a pass.
   - If using custom threshold, convert `score` to a number and compare. E.g., require ≥30.
   - If specific stamps are required, ensure those stamps appear in `stamp_scores` or in a separate data structure. For example, if “Twitter” is required, check `stamp_scores.Twitter` exists and perhaps is above 0. (Even a low value indicates the stamp was present; the exact value is a weight).
   - If any required stamp is missing, mark as fail (even if overall score might be high without it, depending on policy).
   - If the user has no Passport or score is null/0, definitely fail.
4. **Result Branching:**
   - **Pass:** If criteria met, proceed to assign role.
   - **Fail:** If not met, inform the user appropriately. For instance, if it’s score-based: “Your Gitcoin Passport score is 10, which is below the required threshold. To increase it, you can add more verifications to your Passport (e.g., verify Twitter, GitHub, etc.). Then come back to try again.” If specific stamps missing: “You need to have the following verifications in your Passport: Twitter, Google. Please add them on passport.gitcoin.co and then refresh your score.”
   - If the user doesn’t have a Passport at all: “No Passport found for your address. You can create one at passport.gitcoin.co by signing in with your wallet and adding verifications.”
5. **Assign Role:** On success, assign the configured CG role (“Passport Verified”).
6. **Feedback:** Show success, e.g., “✅ Gitcoin Passport verification passed. Score: 33 (Humanity verified).” Possibly display their score or a generic success. On failure, as described, give guidance. The plugin might allow a “Retry” button if the user indicates they’ve updated their Passport (bearing in mind the note about delays).
7. **Retry logic:** The user might go and improve their Passport then come back. The onboarding wizard could remain open. They hit retry; the plugin calls the API again. The API might now show a higher score or new stamps. If it passes this time, great. (They might have to wait a bit if scoring isn’t instant; the UI can hint “If you just added stamps, wait a minute before retry.”).
8. **Proceed or Skip:** If it remains failing and the user cannot fix it, and if the community allowed skipping this (unlikely if they put it as required for a role), they could skip but then they wouldn’t get the role.

**Performance:** The Passport API call is an external HTTP call; it should be pretty fast (some tens of milliseconds to a second). Doing it server-side means the user waits on the request. We should handle errors (if the API is down or returns 500, etc.) by showing a message or allowing retry. Also, ensure not to expose the API key in any front-end network calls (the call should happen server-to-server).

**Storing results:** For auditability, the plugin could store the user’s passport score at time of onboarding (and maybe their passport ID or some reference). However, it’s dynamic data; probably no need to store beyond maybe logging.

One more detail: The admin’s scorer might have a built-in threshold but not necessarily known to the plugin unless it reads docs or the admin configures it. In the API response, they gave `"passing_score": true` as an output, so we can trust that as default criterion (the admin chose Unique Humanity, threshold ~20). If admin overrides threshold, ignore `passing_score` and use our own check.

After this step, the community has confidence the user is a real human (if passed). This can help prevent sybil attacks in things like airdrops, governance, etc.

## Conclusion

By integrating these third-party services into the Common Ground onboarding wizard, we enable communities to thoroughly vet and welcome new members in a seamless, automated way. Each module – Guild.xyz, Discord, Telegram, ENS, EFP, and Gitcoin Passport – adds a layer of verification, from social accounts to on-chain credentials, which can trigger role assignments in the community. The architecture outlined ensures the system is **scalable and modular**: admins can pick and configure the steps relevant to their community, and the plugin handles each integration in isolation while maintaining a unified user flow.

Using standard protocols (OAuth2, web3 transactions, API calls) and libraries (NextAuth, ethers.js, Guild SDK, etc.) as recommended will make the implementation robust and easier to maintain. As the Web3 ecosystem evolves, the plugin’s modular nature will allow adding or updating integrations (for instance, supporting a new identity protocol) without overhauling the entire system.

With this guide, a developer should be able to implement each verification step with clarity on the technical requirements and user experience. The result will be a **powerful onboarding toolkit** for Common Ground communities – one that boosts security and trust by verifying users’ linked accounts and credentials, all while giving users a clear path to become recognized, role-bearing members of the community. 

